{"version":3,"sources":["app.js"],"names":["d","console","log","bind","EMPTY_CELL_VALUE","BOARD_SIZE","cell","value","isWinner","reset","this","checkForWin","state","size","generateWinLocations","cellNumber","row","col","horizontal","aGroup","c","r","cellGroups","push","vertical","diagonal","diagonal1","diagonal2","concat","checkForWinBruteForce","checkHorizontal","y","x","expected","winningLine","length","winner","line","checkVertical","checkDiagonal","board","initialize","i","toGrid","grid","get","isGameOver","nextMark","checkForDraw","isValidMove","rowOrCellNumber","undefined","playMove","setWinner","who","forEach","coords","AIs","dumb","wikipedia","mark","win","slice","cn","anyEmptySquare","strategies","pick","Error","PLAYER","HUMAN","COMPUTER","angular","module","filter","n","list","controller","vm","xplayer","isRunning","selectPlayer","handleWin","player","directive","GameBoardController","ai","isComputerPlayer","parseInt","readyToStart","computerMove","move","resetBoard","onWon","restrict","templateUrl","controllerAs","scope","bindToController","link","$watch","oldValue","arguments","PlayerchooserController","handleSelection","selection","fireSelect"],"mappings":"AAAA,YAEA,IAAAA,GAAAC,QAAAC,IAAAC,KAAAF,SAKAG,iBAAA,KACAC,WAAA,EACAC,KAAA,SAAAC,EAAAC,GACA,OACAD,MAAAA,GAAAH,iBACAI,SAAAA,IAAA,EACAC,MAAA,WACAC,KAAAH,MAAAA,GAAAH,iBACAM,KAAAF,SAAAA,IAAA,KAIAG,YAAA,SAAAC,EAAAC,GACA,GAAAC,GAAA,SAAAD,GACA,GAAAE,GAAA,SAAAC,EAAAC,GACA,MAAAD,GAAAH,EAAAI,GAEAC,EAAA,SAAAL,GACA,GACAM,GAAAC,EAAAC,EADAC,IAEA,KAAAD,EAAA,EAAAR,EAAAQ,EAAAA,IAAA,CAEA,IADAF,KACAC,EAAA,EAAAP,EAAAO,EAAAA,IACAD,EAAAI,KAAAR,EAAAM,EAAAD,GAEAE,GAAAC,KAAAJ,GAEA,MAAAG,IAEAE,EAAA,SAAAX,GACA,GACAM,GAAAE,EAAAD,EADAE,IAEA,KAAAD,EAAA,EAAAR,EAAAQ,EAAAA,IAAA,CAEA,IADAF,KACAC,EAAA,EAAAP,EAAAO,EAAAA,IACAD,EAAAI,KAAAR,EAAAM,EAAAD,GAEAE,GAAAC,KAAAJ,GAEA,MAAAG,IAEAG,EAAA,SAAAZ,GACA,GAAAS,MACAI,KACAC,KACAN,EAAA,EACAD,EAAA,CAEA,GACAM,GAAAH,KAAAR,EAAAM,EAAAD,IACAO,EAAAJ,KAAAR,EAAAF,EAAAQ,EAAAD,IACAA,IACAC,UACAR,EAAAO,EACA,OAAAE,GAEA,OAAAJ,GAAAL,GACAe,OAAAJ,EAAAX,IACAe,OAAAH,EAAAZ,IAEA,OAAAC,GAAAD,IAIAgB,sBAAA,SAAAjB,GACA,GAAAkB,GAAA,WACA,GAAAC,GAAAC,EACAC,EACAC,CACA,KAAAH,EAAA,EAAAA,EAAAnB,EAAAuB,OAAAJ,IAEA,GADAE,EAAArB,EAAAmB,GAAA,GAAAxB,MACA0B,IAAA7B,iBAAA,CAIA,IAHA8B,IACAH,EAAA,IAEAC,EAAA,EAAAA,EAAApB,EAAAmB,GAAAI,OAAAH,IAAA,CACA,GAAApB,EAAAmB,GAAAC,GAAAzB,QAAA0B,EAAA,CACAC,EAAA,IACA,OAEAA,EAAAX,MAAAQ,EAAAC,IAGA,GAAA,OAAAE,EACA,OACAE,OAAAH,EACAI,KAAAH,GAIA,OAAA,GAEAI,EAAA,WACA,GAAAP,GAAAC,EACAC,EACAC,CACA,KAAAF,EAAA,EAAAA,EAAApB,EAAA,GAAAuB,OAAAH,IAEA,GADAC,EAAArB,EAAA,GAAAoB,GAAAzB,MACA0B,IAAA7B,iBAAA,CAIA,IAHA8B,IACA,EAAAF,IAEAD,EAAA,EAAAA,EAAAnB,EAAAuB,OAAAJ,IAAA,CACA,GAAAnB,EAAAmB,GAAAC,GAAAzB,QAAA0B,EAAA,CACAC,EAAA,IACA,OACAA,EAAAX,MAAAQ,EAAAC,IAEA,GAAA,OAAAE,EACA,OACAE,OAAAH,EACAI,KAAAH,GAIA,OAAA,GAEAK,EAAA,WACA,GAGAL,GAHAH,EAAA,EACAC,EAAA,EACAC,EAAArB,EAAA,GAAA,GAAAL,KAGA,IAAA0B,IAAA7B,iBAAA,CAIA,IAHA8B,IACA,EAAA,IAEAH,EAAAnB,EAAAuB,QAAAH,EAAApB,EAAAmB,GAAAI,QAAA,CACA,GAAAF,IAAArB,EAAAmB,GAAAC,GAAAzB,MAAA,CACA2B,EAAA,IACA,OACAA,EAAAX,MAAAQ,EAAAC,IACAA,IACAD,IAEA,GAAA,OAAAG,EACA,OACAE,OAAAH,EACAI,KAAAH,GAWA,GANAF,EAAA,EAAAD,EAAAnB,EAAAuB,OAAA,EACAF,EAAArB,EAAAmB,GAAA,GAAAxB,MACA2B,IACAH,EAAA,IAEAA,IACAE,IAAA7B,iBAAA,CACA,KAAA2B,GAAA,GAAAC,EAAApB,EAAAmB,GAAAI,QAAA,CACA,GAAAF,IAAArB,EAAAmB,GAAAC,GAAAzB,MAAA,CACA2B,EAAA,IACA,OACAA,EAAAX,MAAAQ,EAAAC,IACAA,IACAD,IAEA,GAAA,OAAAG,EACA,OACAE,OAAAH,EACAI,KAAAH,GAIA,OAAA,GAEAE,GAAA,CAEA,QAAAA,EAAAN,OAAAM,EAAAE,OAAAF,EAAAG,KACAH,GAEA,GAGAI,MAAA,SAAA3B,EAAAN,GAEA,GAAAkC,GAAA,SAAA5B,EAAAN,GACA,GACAmC,GADA9B,IAGA,KAAA8B,EAAA,EAAA7B,EAAAA,EAAA6B,EAAAA,IACA9B,EAAA8B,GAAApC,KAAAC,EAEA,OAAAK,IAEA+B,EAAA,SAAA/B,GAGA,IAAA,GAFAgC,MACA5B,KACA0B,EAAA,EAAAA,EAAA9B,EAAAuB,OAAAO,IACA1B,EAAAO,KAAAX,EAAA8B,IACAA,EAAA7B,IAAAA,EAAA,IACA+B,EAAArB,KAAAP,GACAA,KAGA,OAAA4B,IAEAhC,EAAA6B,EAAA5B,EAAAN,GACAqC,EAAAD,EAAA/B,GACA4B,GACAK,IAAA,SAAA7B,EAAAC,GACA,MAAAP,MAAAE,MAAAI,EAAAH,EAAAI,IAEAL,MAAAA,EACAkC,YAAA,EACAC,SAAA,IACApC,YAAAkB,sBAAA1B,KAAAqC,EAAAI,GACAI,aAAA,SAAApC,GACA,GAAA8B,EACA,KAAAA,EAAA,EAAAA,EAAA9B,EAAAuB,OAAAO,IACA,GAAA9B,EAAA8B,GAAAnC,QAAAH,iBAAA,OAAA,CAEA,QAAA,GAEA6C,YAAA,SAAAC,EAAAjC,GACA,GAAAX,GAAA6C,SAAAlC,EAAAP,KAAAE,MAAAsC,GAAAxC,KAAAmC,IAAAK,EAAAjC,EACA,OAAAX,GAAAC,QAAAH,kBAEAgD,SAAA,SAAAF,EAAAjC,GACA,GAAAX,GAAA6C,SAAAlC,EAAAP,KAAAE,MAAAsC,GAAAxC,KAAAmC,IAAAK,EAAAjC,EACA,KAAAP,KAAAoC,YAAAxC,EAAAC,QAAAH,iBAAA,CACAE,EAAAC,MAAAG,KAAAqC,SACArC,KAAAqC,SAAA,MAAArC,KAAAqC,SAAA,IAAA,GAEA,IAAAX,IAAA,GACAA,EAAA1B,KAAAC,gBACAD,KAAAoC,YAAA,EACApC,KAAA2C,UAAAjB,EAAAA,OAAAA,EAAAC,OACA3B,KAAAsC,aAAApC,KACAF,KAAAoC,YAAA,KAIAF,KAAAA,EACAS,UAAA,SAAAC,EAAAjB,GACA3B,KAAA0B,OAAAkB,EACAjB,EAAAkB,QAAA,SAAAC,GACA,GAAAxB,GAAAD,CACAA,GAAAyB,EAAA,GACAxB,EAAAwB,EAAA,GACA9C,KAAAmC,IAAAd,EAAAC,GAAAxB,UAAA,GACAE,OAEAD,MAAA,WACA,IAAA,GAAAiC,GAAA,EAAAA,EAAAhC,KAAAE,MAAAuB,OAAAO,IACAhC,KAAAE,MAAA8B,GAAAjC,OAEAC,MAAAoC,YAAA,EACApC,KAAAqC,SAAA,KAGA,OAAAP,IAGAiB,KAEAC,KAAA,SAAA9C,GACA,GAAAG,EACA,KAAAA,EAAA,EAAAA,EAAAH,EAAAuB,OAAApB,IACA,GAAAH,EAAAG,GAAAR,QAAAH,iBAAA,MAAAW,EAEA,OAAA,OAEA4C,UAAA,SAAA/C,EAAAgD,GACA,GACAC,IADAjD,EAAAkD,QACA,SAAAlD,EAAAgD,GACA,IAAA,GAAAG,GAAA,EAAAA,EAAAnD,EAAAuB,OAAA4B,IACA,GAAAnD,EAAAmD,GAAAxD,QAAAH,mBACAQ,EAAAmD,GAAAH,EACA/B,sBAAAjB,IACA,MAAAmD,EAIA,QAAA,IAEAC,EAAA,SAAApD,GACA,IAAA,GAAAmD,GAAA,EAAAA,EAAAnD,EAAAuB,OAAA4B,IACA,GAAAnD,EAAAmD,GAAAxD,QAAAH,iBAAA,MAAA2D,EAEA,QAAA,GAEAE,GAAAJ,EAAAG,GACAE,EAAA,SAAAD,EAAArD,EAAAgD,GACA,GAAAlB,GAAApC,CACA,KAAAoC,EAAA,EAAAA,EAAAuB,EAAA9B,OAAAO,IACA,GAAApC,EAAA2D,EAAAvB,GAAA9B,EAAAkD,QAAAF,GAAA,MAAAtD,EAEA,MAAA,IAAA6D,OAAA,wBAGA,OAAAD,GAAAD,EAAArD,EAAAgD,KA6BAQ,QACAC,MAAA,EACAC,SAAA,EAGAC,SACAC,OAAA,gBACAC,OAAA,QAAA,WACA,MAAA,UAAAC,GAEA,IAAA,GADAC,MACAjC,EAAA,EAAAgC,EAAAhC,EAAAA,IAAAiC,EAAApD,KAAAmB,EACA,OAAAiC,MAGAC,WAAA,kBAAA,WACA,GAAAC,GAAAnE,IACAmE,GAAAC,SAAA,EACAD,EAAAE,WAAA,EACAF,EAAAG,aAAA,SAAAF,GACA9E,EAAA8E,GACApE,KAAAoE,QAAAA,EACApE,KAAAqE,WAAA,GAEAF,EAAAI,UAAA,SAAAC,GACAlF,EAAA,QAAAkF,GACAxE,KAAA0B,OAAA8C,EACAxE,KAAAqE,WAAA,MAGAI,UAAA,aAAA,WAIA,GACAC,IAAA,WAEA,GACAC,GAAA5B,IAAAC,KAEA4B,EAAA,SAAAJ,GACA,MAAAK,UAAAL,EAAA,MAAAd,OAAAE,SAEAtE,GAAA,YAAAU,MACAA,KAAA8E,cAAA,EACA9E,KAAA8B,MAAAA,MAAAnC,WAAAD,kBAEAM,KAAA+E,aAAA,WACA,GAAAC,GAAAL,EAAA3E,KAAA8B,MAAA5B,MAAAF,KAAA8B,MAAAO,SACArC,MAAA8B,MAAAY,SAAAsC,IAGAhF,KAAAiF,WAAA,WACA3F,EAAA,cACAU,KAAA8B,MAAA/B,QACA6E,EAAA5E,KAAAoE,UACApE,KAAA+E,eAEA/E,KAAAqE,WAAA,GAGArE,KAAAkD,KAAA,SAAA5C,EAAAC,GAIA,GAHAjB,EAAA,QAAAU,MAEAV,EAAAU,KAAA8B,MAAAK,IAAA7B,EAAAC,IACAP,KAAA8B,MAAAM,WACApC,KAAAiF,iBACA,CACA,IAAAjF,KAAA8B,MAAAS,YAAAjC,EAAAC,GAAA,MACAP,MAAA8B,MAAAY,SAAApC,EAAAC,GACAP,KAAA8B,MAAAM,YACApC,KAAA+E,eAGA/E,KAAA8B,MAAAM,YACA,OAAApC,KAAA8B,MAAAJ,SACApC,EAAA,QACAU,KAAAkF,OACAV,OAAAxE,KAAA8B,MAAAJ,YAQA,QACAyD,SAAA,IAEAC,YAAA,iBACAlB,WAAAQ,EACAW,aAAA,IACAC,OACAlB,QAAA,IACAC,UAAA,IACAa,MAAA,KAEAK,kBAAA,EACAC,KAAA,SAAAF,GACAA,EAAAG,OAAA,cAAA,SAAA5F,EAAA6F,GACApG,EAAAqG,WACA9F,KAAA,GAAA6F,KAAA,GACAJ,EAAA5E,EAAAuE,eAGAK,EAAAG,OAAA,YACA,mBAWAhB,UAAA,iBAAA,WAEA,GACAmB,IAAA,WACA5F,KAAA2D,MAAAD,OAAAC,MACA3D,KAAA4D,SAAAF,OAAAE,SAGA5D,KAAA6F,gBAAA,SAAAC,GACAxG,EAAAwG,GACA9F,KAAA+F,YACA3B,QAAA0B,MAKA,QACAX,SAAA,IACAC,YAAA,sBAEAlB,WAAA0B,EACAP,aAAA,MACAC,OACAS,WAAA,oBAEAR,kBAAA","file":"app.min.js","sourcesContent":["'use strict';\n\nvar d = console.log.bind(console) // eslint-disable-line no-undef, no-console\n;\n\n\n// @TODO Try out magic square method of checking if puzzle is solved\nvar EMPTY_CELL_VALUE = null,\n    BOARD_SIZE = 3,\n    cell = function(value, isWinner) {\n        return {\n            value: value || EMPTY_CELL_VALUE,\n            isWinner: isWinner || false,\n            reset: function() {\n                this.value = value || EMPTY_CELL_VALUE;\n                this.isWinner = isWinner || false;\n            }\n        };\n    },\n    checkForWin = function(state, size) { //eslint-disable-line no-unused-vars\n        var generateWinLocations = function(size) {\n            var cellNumber = function(row, col) {\n                return row * size + col;\n            },\n                horizontal = function(size) {\n                    var cellGroups = [],\n                        aGroup, c, r;\n                    for (r = 0; r < size; r++) {\n                        aGroup = [];\n                        for (c = 0; c < size; c++) {\n                            aGroup.push(cellNumber(r, c));\n                        }\n                        cellGroups.push(aGroup);\n                    }\n                    return cellGroups;\n                },\n                vertical = function(size) {\n                    var cellGroups = [],\n                        aGroup, r, c;\n                    for (r = 0; r < size; r++) {\n                        aGroup = [];\n                        for (c = 0; c < size; c++) {\n                            aGroup.push(cellNumber(r, c));\n                        }\n                        cellGroups.push(aGroup);\n                    }\n                    return cellGroups;\n                },\n                diagonal = function(size) {\n                    var cellGroups = [],\n                        diagonal1 = [],\n                        diagonal2 = [],\n                        r = 0,\n                        c = 0;\n\n                    do {\n                        diagonal1.push(cellNumber(r, c));\n                        diagonal2.push(cellNumber(size - r, c));\n                        c++;\n                        r++;\n                    } while (c < size);\n                    return cellGroups;\n                };\n            return horizontal(size)\n                .concat(vertical(size))\n                .concat(diagonal(size));\n        };\n        return generateWinLocations(size);\n    },\n    // Cell[]* -> Winner | false\n    // Checks board state and returns the winner or false\n    checkForWinBruteForce = function(state) {\n        var checkHorizontal = function() {\n            var y, x,\n                expected,\n                winningLine;\n            for (y = 0; y < state.length; y++) {\n                expected = state[y][0].value;\n                if (expected === EMPTY_CELL_VALUE) continue;\n                winningLine = [\n                    [y, 0]\n                ];\n                for (x = 1; x < state[y].length; x++) {\n                    if (state[y][x].value !== expected) {\n                        winningLine = null;\n                        break;\n                    } else {\n                        winningLine.push([y, x]);\n                    }\n                }\n                if (winningLine !== null) {\n                    return {\n                        winner: expected,\n                        line: winningLine\n                    };\n                }\n            }\n            return false;\n        },\n            checkVertical = function() {\n                var y, x,\n                    expected,\n                    winningLine;\n                for (x = 0; x < state[0].length; x++) {\n                    expected = state[0][x].value;\n                    if (expected === EMPTY_CELL_VALUE) continue;\n                    winningLine = [\n                        [0, x]\n                    ];\n                    for (y = 1; y < state.length; y++) {\n                        if (state[y][x].value !== expected) {\n                            winningLine = null;\n                            break;\n                        } else winningLine.push([y, x]);\n                    }\n                    if (winningLine !== null) {\n                        return {\n                            winner: expected,\n                            line: winningLine\n                        };\n                    }\n                }\n                return false;\n            },\n            checkDiagonal = function() {\n                var y = 1,\n                    x = 1,\n                    expected = state[0][0].value,\n                    winningLine;\n\n                if (expected !== EMPTY_CELL_VALUE) {\n                    winningLine = [\n                        [0, 0]\n                    ];\n                    while (y < state.length && x < state[y].length) {\n                        if (expected !== state[y][x].value) {\n                            winningLine = null;\n                            break;\n                        } else winningLine.push([y, x]);\n                        x++;\n                        y++;\n                    }\n                    if (winningLine !== null) {\n                        return {\n                            winner: expected,\n                            line: winningLine\n                        };\n                    }\n                }\n\n                x = 1, y = state.length - 1;\n                expected = state[y][0].value;\n                winningLine = [\n                    [y, 0]\n                ];\n                y--;\n                if (expected !== EMPTY_CELL_VALUE) {\n                    while (y >= 0 && x < state[y].length) {\n                        if (expected !== state[y][x].value) {\n                            winningLine = null;\n                            break;\n                        } else winningLine.push([y, x]);\n                        x++;\n                        y--;\n                    }\n                    if (winningLine !== null) {\n                        return {\n                            winner: expected,\n                            line: winningLine\n                        };\n                    }\n                }\n                return false;\n            },\n            winner = false;\n\n        if ((winner = checkHorizontal()) || (winner = checkVertical()) || (winner = checkDiagonal())) {\n            return winner;\n        } else {\n            return false;\n        }\n    },\n    board = function(size, value) {\n\n        var initialize = function(size, value) {\n            var state = [],\n                i;\n\n            for (i = 0; i < size * size; i++) {\n                state[i] = cell(value);\n            }\n            return state;\n        },\n            toGrid = function(state) {\n                var grid = [],\n                    row = [];\n                for (var i = 0; i < state.length; i++) {\n                    row.push(state[i]);\n                    if (i % size === (size - 1)) {\n                        grid.push(row);\n                        row = [];\n                    }\n                }\n                return grid;\n            },\n            state = initialize(size, value),\n            grid = toGrid(state),\n            board = {\n                get: function(row, col) {\n                    return this.state[row * size + col];\n                },\n                state: state,\n                isGameOver: false,\n                nextMark: 'X',\n                checkForWin: checkForWinBruteForce.bind(board, grid),\n                checkForDraw: function(state) {\n                    var i;\n                    for (i=0; i<state.length; i++) {\n                        if (state[i].value===EMPTY_CELL_VALUE) return false;\n                    }\n                    return true;\n                },\n                isValidMove: function(rowOrCellNumber, col) {\n                    var cell = col === undefined ? this.state[rowOrCellNumber] : this.get(rowOrCellNumber, col);\n                    return cell.value === EMPTY_CELL_VALUE;\n                },\n                playMove: function(rowOrCellNumber, col) {\n                    var cell = col === undefined ? this.state[rowOrCellNumber] : this.get(rowOrCellNumber, col);\n                    if (!this.isGameOver && cell.value === EMPTY_CELL_VALUE) {\n                        cell.value = this.nextMark;\n                        this.nextMark = this.nextMark === 'X' ? 'O' : 'X';\n\n                        var winner = false;\n                        if ((winner = this.checkForWin())) {\n                            this.isGameOver = true;\n                            this.setWinner(winner.winner, winner.line);\n                        } else if( this.checkForDraw(state) ) {\n                            this.isGameOver = true;\n                        }\n                    }\n                },\n                grid: grid,\n                setWinner: function(who, line) {\n                    this.winner = who;\n                    line.forEach(function(coords) {\n                        var x, y;\n                        y = coords[0];\n                        x = coords[1];\n                        this.get(y, x).isWinner = true;\n                    }, this);\n                },\n                reset: function() {\n                    for (var i = 0; i < this.state.length; i++) {\n                        this.state[i].reset();\n                    }\n                    this.isGameOver = false;\n                    this.nextMark = 'X';\n                }\n            };\n        return board;\n    },\n\n    AIs = {\n        // find the next free space\n        dumb: function(state) {\n            var cellNumber;\n            for (cellNumber = 0; cellNumber < state.length; cellNumber++) {\n                if (state[cellNumber].value === EMPTY_CELL_VALUE) return cellNumber;\n            }\n            return null;\n        },\n        wikipedia: function(state, mark) {\n            var s = state.slice(),\n                win = function(state, mark) {\n                    for(var cn=0; cn<state.length; cn++) {\n                        if(state[cn].value===EMPTY_CELL_VALUE) {\n                            state[cn]=mark;\n                            if( checkForWinBruteForce(state) ) {\n                                return cn;\n                            }\n                        }\n                    }\n                    return false;\n                },\n                anyEmptySquare = function(state) {\n                    for(var cn=0; cn<state.length; cn++) {\n                         if(state[cn].value===EMPTY_CELL_VALUE) return cn\n                    }\n                    return false;\n                },\n                strategies = [ win, anyEmptySquare ],\n                pick = function(strategies, state, mark) {\n                    var i, cell;\n                    for(i=0; i<strategies.length; i++) {\n                        if( (cell=strategies[i](state.slice(), mark)) ) return cell;\n                    }\n                    throw new Error(\"Should not get here.\");\n                }\n            ;\n            return pick(strategies, state, mark);\n        }\n    };\n//        // http://www.flyingmachinestudios.com/programming/minimax/\n//        // http://aihorizon.com/essays/basiccs/trees/minimax.htm\n//        //http://neverstopbuilding.com/minimax\n//        minimax: function(state, type) {\n//\n//        }\n//    },\n//    flatten = function flatten(arr) {\n//        return arr.reduce(function(flat, item) {\n//            return flat.concat(item);\n//        }, []);\n//    },\n//\n//    // assumes flattend state before hand: state = flatten(state);\n//    generateMoves = function(state, nextPlayer) {\n//        var moves = [];\n//        state.forEach(function(cell, i) {\n//            if( cell.value===EMPTY_CELL_VALUE ) {\n//                var nextBoard = clone(state);\n//                nextBoard[i] = nextP(nextPlayer);\n//                moves.push(nextBoard);\n//            }\n//        });\n//    }\n//;\n\nvar PLAYER = {\n    HUMAN: 1,\n    COMPUTER: 2\n};\n\nangular\n    .module('ticTacToe', [])\n    .filter('range', function() {\n        return function(n) {\n            var list = [];\n            for (var i = 0; i < n; i++) list.push(i);\n            return list;\n        };\n    })\n    .controller('GameController', [function() {\n        var vm = this;\n        vm.xplayer = false;\n        vm.isRunning = false;\n        vm.selectPlayer = function(xplayer) {\n            d(xplayer);\n            this.xplayer = xplayer;\n            this.isRunning = true;\n        };\n        vm.handleWin = function(player) {\n            d('won: ', player);\n            this.winner = player;\n            this.isRunning = false;\n        };\n    }])\n    .directive('gameBoard', [function() {\n\n\n        //        var template = '',\n        var\n        GameBoardController = [function() {\n            // x always first\n            var //self = this,\n            ai = AIs.dumb,\n            // ai = AIs.wikipedia,\n            isComputerPlayer = function(player) {\n                return parseInt(player, 10)===PLAYER.COMPUTER;\n            };\n            d('construct', this);\n            this.readyToStart = false;\n            this.board = board(BOARD_SIZE, EMPTY_CELL_VALUE);\n\n            this.computerMove = function() {\n                var move = ai(this.board.state, this.board.nextMark);\n                this.board.playMove(move);\n            }\n\n            this.resetBoard = function() {\n                d('Reset game');\n                this.board.reset();\n                if (isComputerPlayer(this.xplayer)) {\n                    this.computerMove();\n                }\n                this.isRunning=true;\n            };\n\n            this.mark = function(row, col) {\n                d('this:', this);\n                //if ( !this.readyToStart ) return;\n                d(this.board.get(row, col));\n                if (this.board.isGameOver) {\n                    this.resetBoard();\n                } else {\n                    if( !this.board.isValidMove(row, col) ) return;\n                    this.board.playMove(row, col);\n                    if (!this.board.isGameOver) {\n                        this.computerMove();\n                    }\n                }\n                if (this.board.isGameOver) {\n                    if ( this.board.winner!==null ) {\n                        d('Won!');\n                        this.onWon({\n                            player: this.board.winner\n                        });\n                    }\n                }\n            };\n        }];\n\n\n        return {\n            restrict: 'E',\n            //            template: template\n            templateUrl: 'gameboard.html',\n            controller: GameBoardController,\n            controllerAs: 'c',\n            scope: {\n                xplayer: '@',\n                isRunning:'=',\n                onWon: '&'\n            },\n            bindToController: true,\n            link: function(scope) {\n                scope.$watch('c.isRunning', function(value, oldValue) {\n                    d(arguments);\n                    if( value===true && oldValue===false ) {\n                        scope.c.resetBoard();\n                    }\n                });\n                scope.$watch('c.xplayer',\n                             function() {\n                                 //d('Gameboard: xplayer changed.', arguments, scope);\n                                 //if( value!=='false' ) value = parseInt(value, 10);\n                                 //d('value before set: ', value);\n                                 //scope.xplayer = value;\n                                 // scope.c.resetBoard();\n                                 //   if( typeof this.resetBoard === 'function' ) this.resetBoard();\n                             });\n            }\n        };\n    }])\n    .directive('playerChooser', [function() {\n\n        var\n        PlayerchooserController = [function() {\n            this.HUMAN = PLAYER.HUMAN;\n            this.COMPUTER = PLAYER.COMPUTER;\n\n\n            this.handleSelection = function(selection) {\n                d(selection);\n                this.fireSelect({\n                    xplayer: selection\n                });\n            };\n        }];\n\n        return {\n            restrict: 'E',\n            templateUrl: 'player-chooser.html',\n            //            template: \"<p>choose</p>\",\n            controller: PlayerchooserController,\n            controllerAs: 'pcc',\n            scope: {\n                fireSelect: '&onSelectXplayer'\n            },\n            bindToController: true\n        };\n    }]);\n//d(checkForWin([], 3));\n"],"sourceRoot":"/source/"}