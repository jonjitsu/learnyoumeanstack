{"version":3,"sources":["app.js"],"names":["d","console","log","bind","EMPTY_CELL_VALUE","BOARD_SIZE","cell","value","isWinner","reset","this","checkForWinBruteForce","state","wins","isWinningLine","line","i","expected","length","winners","filter","winner","board","size","initialize","toFlatArray","map","get","row","col","asArray","isGameOver","nextMark","checkForWin","checkForDraw","isValidMove","rowOrCellNumber","undefined","playMove","setWinner","who","forEach","c","AIs","dumb","cellNumber","wikipedia","mark","opponent","countWinningPositions","cn","count","hasFork","withEmptyCells","fn","result","slice","emptySide","anyEmptySquare","win","block","fork","blockFork","opFork","center","oppositeCorner","op","emptyCorner","areAllCornersEmpty","strategies","pick","Error","PLAYER","HUMAN","COMPUTER","angular","module","n","list","push","controller","vm","xplayer","isRunning","selectPlayer","handleWin","player","directive","GameBoardController","ai","isComputerPlayer","parseInt","readyToStart","computerMove","move","resetBoard","onWon","restrict","templateUrl","controllerAs","scope","bindToController","link","$watch","oldValue","arguments","PlayerchooserController","handleSelection","selection","fireSelect"],"mappings":"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","file":"app.min.js","sourcesContent":["'use strict';\n\nvar d = console.log.bind(console) // eslint-disable-line no-undef, no-console\n;\n\n\n// @TODO Try out magic square method of checking if puzzle is solved\nvar EMPTY_CELL_VALUE = null,\n    BOARD_SIZE = 3,\n    cell = function(value, isWinner) {\n        return {\n            value: value || EMPTY_CELL_VALUE,\n            isWinner: isWinner || false,\n            reset: function() {\n                this.value = value || EMPTY_CELL_VALUE;\n                this.isWinner = isWinner || false;\n            }\n        };\n    },\n    // Cell[]* -> Winner | false\n    // Checks board state and returns the winner or false\n    checkForWinBruteForce = function(state) {\n        var wins = [\n            // horizontals\n            [0,1,2], [3,4,5], [6,7,8],\n            // verticals\n            [0,3,6], [1,4,7], [2,5,8],\n            // diagonals\n            [0,4,8], [6,4,2]\n        ],\n            isWinningLine = function(line) {\n                var i, expected = state[line[0]];\n\n                if( expected===EMPTY_CELL_VALUE ) return false;\n\n                for(i=1; i<line.length; i++) {\n                    if( state[line[i]]!==expected ) return false;\n                }\n                return true;\n            },\n            winners = wins.filter(isWinningLine);\n        if( winners.length>0 ) {\n            return {\n                winner: state[winners[0][0]],\n                line: winners[0]\n            };\n        } else {\n            return false;\n        }\n    },\n    board = function(size, value) {\n\n        var initialize = function(size, value) {\n            var state = [],\n                i;\n\n            for (i = 0; i < size * size; i++) {\n                state[i] = cell(value);\n            }\n            return state;\n        },\n            toFlatArray = function(state) {\n                return state.map(function(cell) {\n                    return cell.value;\n                });\n            },\n            state = initialize(size, value),\n            board = {\n                get: function(row, col) {\n                    return this.state[row * size + col];\n                },\n                state: state,\n                asArray: toFlatArray.bind(null, state),\n                isGameOver: false,\n                nextMark: 'X',\n                checkForWin: function() {\n                    return checkForWinBruteForce(this.asArray())\n                },\n                checkForDraw: function(state) {\n                    var i;\n                    for (i=0; i<state.length; i++) {\n                        if (state[i].value===EMPTY_CELL_VALUE) return false;\n                    }\n                    return true;\n                },\n                isValidMove: function(rowOrCellNumber, col) {\n                    var cell = col === undefined ? this.state[rowOrCellNumber] : this.get(rowOrCellNumber, col);\n                    return cell.value === EMPTY_CELL_VALUE;\n                },\n                playMove: function(rowOrCellNumber, col) {\n                    var cell = col === undefined ? this.state[rowOrCellNumber] : this.get(rowOrCellNumber, col);\n                    if (!this.isGameOver && cell.value === EMPTY_CELL_VALUE) {\n                        cell.value = this.nextMark;\n                        this.nextMark = this.nextMark === 'X' ? 'O' : 'X';\n\n                        var winner = false;\n                        if ((winner = this.checkForWin())) {\n                            this.isGameOver = true;\n                            this.setWinner(winner.winner, winner.line);\n                        } else if( this.checkForDraw(state) ) {\n                            this.isGameOver = true;\n                        }\n                    }\n                },\n                setWinner: function(who, line) {\n                    this.winner = who;\n                    line.forEach(function(c) {\n                        this.state[c].isWinner = true;\n                    }, this);\n                },\n                reset: function() {\n                    for (var i = 0; i < this.state.length; i++) {\n                        this.state[i].reset();\n                    }\n                    this.isGameOver = false;\n                    this.nextMark = 'X';\n                }\n            };\n        return board;\n    },\n\n    AIs = {\n        // find the next free space\n        dumb: function(state) {\n            var cellNumber;\n            for (cellNumber = 0; cellNumber < state.length; cellNumber++) {\n                if (state[cellNumber].value === EMPTY_CELL_VALUE) return cellNumber;\n            }\n            return null;\n        },\n        wikipedia: function(state, mark) {\n            var opponent = function(mark) { return mark==='X' ? 'O' : 'X'; },\n                countWinningPositions = function(state, mark) {\n                    var count=0, cn;\n                    for(cn=0; cn<state.length; cn++) {\n                        if(state[cn]===EMPTY_CELL_VALUE) {\n                            state[cn]=mark;\n                            if( checkForWinBruteForce(state) ) count++;\n                            state[cn]=EMPTY_CELL_VALUE;\n                        }\n                    }\n                    return count;\n                },\n                hasFork = function(state, mark) {\n                    return countWinningPositions(state, mark) > 1;\n                },\n                withEmptyCells = function(fn) {\n                    var cn, result;\n                    for(cn=0; cn<state.length; cn++) {\n                        if(state[cn]===EMPTY_CELL_VALUE) {\n                            if( (result = fn(cn, state.slice()))!==undefined ) {\n                                return result; \n                            }\n                        }\n                    }\n                    return false;\n                },\n                emptySide = function(state, mark) {\n                    if( state[1]===EMPTY_CELL_VALUE ) return 1;\n                    if( state[3]===EMPTY_CELL_VALUE ) return 3;\n                    if( state[5]===EMPTY_CELL_VALUE ) return 5;\n                    if( state[7]===EMPTY_CELL_VALUE ) return 7;\n                },\n                anyEmptySquare = function(state) {\n                    for(var cn=0; cn<state.length; cn++) {\n                         if(state[cn]===EMPTY_CELL_VALUE) return cn\n                    }\n                    return false;\n                },\n                win = function(state, mark) {\n                    for(var cn=0; cn<state.length; cn++) {\n                        if(state[cn]===EMPTY_CELL_VALUE) {\n                            state[cn]=mark;\n                            if( checkForWinBruteForce(state) ) {\n                                return cn;\n                            }\n                            state[cn]=EMPTY_CELL_VALUE;\n                        }\n                    }\n                    return false;\n                },\n                block = function(state, mark) {\n                    return win(state, opponent(mark));\n                },\n                fork = function(state, mark) {\n                    return withEmptyCells(function(cn, state) {\n                        state[cn]=mark;\n                        if(hasFork(state, mark)) return cn;\n                    })\n                },\n                blockFork = function(state, mark) {\n                    var opFork = fork(state, opponent(mark));\n                    if( opFork ) {\n                        if(state[4]===mark) {\n                            return emptySide(state, mark);\n                        }\n                        return opFork;\n                    }\n                    return false;\n                },\n                center = function(state, mark) {\n                    return state[4]===EMPTY_CELL_VALUE ? 4 : false;\n                },\n                oppositeCorner = function(state, mark) {\n                    var op = opponent(mark);\n                    if( state[0]===op && state[8]===EMPTY_CELL_VALUE ) return 8;\n                    if( state[8]===op && state[0]===EMPTY_CELL_VALUE ) return 0;\n                    if( state[2]===op && state[6]===EMPTY_CELL_VALUE ) return 6;\n                    if( state[6]===op && state[2]===EMPTY_CELL_VALUE ) return 2;\n                    return false;\n                },\n                emptyCorner = function(state, mark) {\n                    var areAllCornersEmpty = function(state) {\n                        return state[0]===EMPTY_CELL_VALUE\n                            && state[2]===EMPTY_CELL_VALUE\n                            && state[6]===EMPTY_CELL_VALUE\n                            && state[8]===EMPTY_CELL_VALUE;\n                    };\n                    return areAllCornersEmpty(state) ? 0 : false;\n                },\n                anyEmptyCorner = function(state, mark) {\n                    if( state[0]===EMPTY_CELL_VALUE ) return 0;\n                    if( state[2]===EMPTY_CELL_VALUE ) return 2;\n                    if( state[6]===EMPTY_CELL_VALUE ) return 6;\n                    if( state[8]===EMPTY_CELL_VALUE ) return 8;\n                    return false;\n                },\n                strategies = [ win, block,\n                               fork,\n                               blockFork,\n                               center,\n                               oppositeCorner,\n                               emptyCorner,\n                               //anyEmptyCorner,\n                               emptySide,\n                               anyEmptySquare ],\n                pick = function(strategies, state, mark) {\n                    var i, cell;\n                    for(i=0; i<strategies.length; i++) {\n                        if( (cell=strategies[i](state.slice(), mark))!==false ) {\n                            d('Strat: ' + i);\n                            return cell;\n                        }\n                    }\n                    throw new Error(\"Should not be here.\");\n                }\n            ;\n            return pick(strategies, state, mark);\n        }\n    };\n//        // http://www.flyingmachinestudios.com/programming/minimax/\n//        // http://aihorizon.com/essays/basiccs/trees/minimax.htm\n//        //http://neverstopbuilding.com/minimax\n//        minimax: function(state, type) {\n//\n//        }\n//    },\n//    flatten = function flatten(arr) {\n//        return arr.reduce(function(flat, item) {\n//            return flat.concat(item);\n//        }, []);\n//    },\n//\n//    // assumes flattend state before hand: state = flatten(state);\n//    generateMoves = function(state, nextPlayer) {\n//        var moves = [];\n//        state.forEach(function(cell, i) {\n//            if( cell.value===EMPTY_CELL_VALUE ) {\n//                var nextBoard = clone(state);\n//                nextBoard[i] = nextP(nextPlayer);\n//                moves.push(nextBoard);\n//            }\n//        });\n//    }\n//;\n\nvar PLAYER = {\n    HUMAN: 1,\n    COMPUTER: 2\n};\n\nangular\n    .module('ticTacToe', [])\n    .filter('range', function() {\n        return function(n) {\n            var list = [];\n            for (var i = 0; i < n; i++) list.push(i);\n            return list;\n        };\n    })\n    .controller('GameController', [function() {\n        var vm = this;\n        vm.xplayer = false;\n        vm.isRunning = false;\n        vm.selectPlayer = function(xplayer) {\n            d(xplayer);\n            this.xplayer = xplayer;\n            this.isRunning = true;\n        };\n        vm.handleWin = function(player) {\n            d('won: ', player);\n            this.winner = player;\n            this.isRunning = false;\n        };\n    }])\n    .directive('gameBoard', [function() {\n\n\n        //        var template = '',\n        var\n        GameBoardController = [function() {\n            // x always first\n            var //self = this,\n            // ai = AIs.dumb,\n            ai = AIs.wikipedia,\n            isComputerPlayer = function(player) {\n                return parseInt(player, 10)===PLAYER.COMPUTER;\n            };\n            d('construct', this);\n            this.readyToStart = false;\n            this.board = board(BOARD_SIZE, EMPTY_CELL_VALUE);\n\n            this.computerMove = function() {\n                var move = ai(this.board.asArray(), this.board.nextMark);\n                this.board.playMove(move);\n            }\n\n            this.resetBoard = function() {\n                d('Reset game');\n                this.board.reset();\n                if (isComputerPlayer(this.xplayer)) {\n                    this.computerMove();\n                }\n                this.isRunning=true;\n            };\n\n            this.mark = function(row, col) {\n                d('this:', this);\n                //if ( !this.readyToStart ) return;\n                d(this.board.get(row, col));\n                if (this.board.isGameOver) {\n                    this.resetBoard();\n                } else {\n                    if( !this.board.isValidMove(row, col) ) return;\n                    this.board.playMove(row, col);\n                    if (!this.board.isGameOver) {\n                        this.computerMove();\n                    }\n                }\n                if (this.board.isGameOver) {\n                    if ( this.board.winner!==null ) {\n                        d('Won!');\n                        this.onWon({\n                            player: this.board.winner\n                        });\n                    }\n                }\n            };\n        }];\n\n\n        return {\n            restrict: 'E',\n            //            template: template\n            templateUrl: 'gameboard.html',\n            controller: GameBoardController,\n            controllerAs: 'c',\n            scope: {\n                xplayer: '@',\n                isRunning:'=',\n                onWon: '&'\n            },\n            bindToController: true,\n            link: function(scope) {\n                scope.$watch('c.isRunning', function(value, oldValue) {\n                    d(arguments);\n                    if( value===true && oldValue===false ) {\n                        scope.c.resetBoard();\n                    }\n                });\n                scope.$watch('c.xplayer',\n                             function() {\n                                 //d('Gameboard: xplayer changed.', arguments, scope);\n                                 //if( value!=='false' ) value = parseInt(value, 10);\n                                 //d('value before set: ', value);\n                                 //scope.xplayer = value;\n                                 // scope.c.resetBoard();\n                                 //   if( typeof this.resetBoard === 'function' ) this.resetBoard();\n                             });\n            }\n        };\n    }])\n    .directive('playerChooser', [function() {\n\n        var\n        PlayerchooserController = [function() {\n            this.HUMAN = PLAYER.HUMAN;\n            this.COMPUTER = PLAYER.COMPUTER;\n\n\n            this.handleSelection = function(selection) {\n                d(selection);\n                this.fireSelect({\n                    xplayer: selection\n                });\n            };\n        }];\n\n        return {\n            restrict: 'E',\n            templateUrl: 'player-chooser.html',\n            //            template: \"<p>choose</p>\",\n            controller: PlayerchooserController,\n            controllerAs: 'pcc',\n            scope: {\n                fireSelect: '&onSelectXplayer'\n            },\n            bindToController: true\n        };\n    }]);\n//d(checkForWin([], 3));\n"],"sourceRoot":"/source/"}